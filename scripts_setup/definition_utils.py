#!/usr/bin/env python3
import re
import subprocess
from pathlib import Path
import shutil
import sys
from typing import List, Dict, Tuple

RED = "\033[91m"
YELLOW = "\033[93m"
GREEN = "\033[92m"
RESET = "\033[0m"

def _log_warning(message: str):
    print(f"{YELLOW}âš ï¸ {message}{RESET}")

def command_exists(command: str) -> bool:
    try:
        base_command_for_check = command.split()[0]
        if Path(base_command_for_check).is_absolute() or \
           (Path.cwd() / base_command_for_check).exists():
            if (Path.cwd() / base_command_for_check).is_file() or Path(base_command_for_check).is_file():
                return True

        result = subprocess.run(
            ["zsh", "-c", f"command -v {base_command_for_check}"],
            capture_output=True,
            text=True,
            check=False
        )
        return result.returncode == 0
    except Exception as e:
        _log_warning(f"Could not check command existence for `{base_command_for_check}`: {e}")
        return False

def get_executable_path(bin_dir: Path, script_filename: str) -> Path:
    name_to_process = script_filename
    
    if name_to_process.endswith(".py%"):
        name_to_process = name_to_process[:-3] 
    elif name_to_process.endswith("%" ) and not name_to_process.endswith(".py%"):
        name_to_process = name_to_process[:-1]

    base_name = name_to_process
    known_extensions = [".py", ".sh", ".pl", ".rb"] 
    for ext_to_strip in known_extensions:
        if name_to_process.endswith(ext_to_strip):
            base_name = name_to_process[:-len(ext_to_strip)]
            break 
            
    return bin_dir / base_name

def parse_definitions_file(file_path: Path) -> Tuple[List[Dict], List[Dict]]:
    aliases = []
    functions = []
    if not file_path.exists():
        _log_warning(f"Definition file not found: {file_path}. Skipping.")
        return aliases, functions

    line_pattern = re.compile(r'^\s*(alias|func)\s*:\s*([^:]+?)\s*:\s*([^:]+?)\s*:\s*"([^"]*)"\s*:\s*(.*)$')

    with open(file_path, "r", encoding="utf-8") as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            match = line_pattern.match(line)
            if not match:
                _log_warning(f"Invalid format in {file_path} (line {line_num}). Skipping. Line: '{line}'")
                continue

            def_type, script_file, name, description, args_str = match.groups()
            
            definition = {
                "script": script_file.strip(),
                "name": name.strip(),
                "description": description.strip(),
                "args": args_str.strip()
            }

            if def_type == 'alias':
                aliases.append(definition)
            else:
                functions.append(definition)
                
    return aliases, functions

def get_existing_definitions(config_file: Path, def_type: str) -> Dict[str, str]:
    definitions = {}
    if not config_file.exists():
        return definitions
    try:
        full_text = config_file.read_text(encoding='utf-8')
        
        if def_type == 'alias':
            # Split by lines for aliases
            blocks = full_text.splitlines()
            for block in blocks:
                block = block.strip()
                if block.startswith("alias "):
                    match = re.match(r"alias\s+([^=]+)=(['\\\"])(.*?)\2", block)
                    if match:
                        name = match.group(1).strip()
                        definitions[name] = block
        else: # func
            # Split by the blank line between each full function definition
            blocks = filter(None, full_text.split('\n\n'))
            for block in blocks:
                # The name can be extracted from the first line for the key
                match = re.search(r'register_function\s+"([^"]+)"', block)
                if match:
                    name = match.group(1)
                    definitions[name] = block.strip()

    except Exception as e:
        _log_warning(f"Error reading existing definition file {config_file}: {e}")
    return definitions

def write_definitions(
    definitions: List[Dict],
    bin_dir: Path,
    output_file: Path,
    source_file_path: str,
    def_type: str,
    verbose: bool = False
) -> None:
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    existing_definitions_map = get_existing_definitions(output_file, def_type)
    newly_created_or_changed = {}
    definitions_to_process = {}
    
    header = [
        f"# Generated by definition_utils.py from {Path(source_file_path).name}",
        "# Do not edit this file directly. Modify the source and rerun the setup.",
    ]
    all_lines = list(header)

    sorted_definitions = sorted(definitions, key=lambda x: x['name'])
    
    for def_data in sorted_definitions:
        name = def_data['name']
        symlink_path = get_executable_path(bin_dir, def_data['script'])
        command = str(symlink_path)
        
        if def_data['args']:
            command += f" {def_data['args']}"
        
        block_text = ""
        if def_type == 'alias':
            full_command = command.strip()
            block_text = f'register_alias "{name}" "{def_data["description"]}"\nalias {name}="{full_command}"'
        else: # func
            full_command = f'{command} "$@"'
            func_block_lines = [
                f'register_function "{name}" "{def_data["description"]}"',
                f"{name}() {{",
                f'    {full_command.strip()}',
                f"}}"
            ]
            block_text = "\n".join(func_block_lines)
        
        if name in definitions_to_process:
            _log_warning(f"Duplicate {def_type} name '{name}' defined in {Path(source_file_path).name}. Using last definition.")
        definitions_to_process[name] = block_text

    sorted_names = sorted(definitions_to_process.keys())

    for name in sorted_names:
        block_text = definitions_to_process[name]
        if name in existing_definitions_map and existing_definitions_map[name] == block_text:
            if verbose: print(f"ðŸ”¹ {def_type.capitalize()} unchanged: {name}")
        else:
            description = next((d['description'] for d in definitions if d['name'] == name), "")
            if name in existing_definitions_map:
                newly_created_or_changed[name] = ('updated', description)
                if verbose: print(f"ðŸ”„ {def_type.capitalize()} updated: {name}")
            else:
                newly_created_or_changed[name] = ('created', description)
                if verbose: print(f"âœ¨ {def_type.capitalize()} created: {name}")

        all_lines.append("") 
        all_lines.append(block_text)

    try:
        with open(output_file, "w", encoding="utf-8") as f:
            f.write("\n".join(all_lines) + "\n")
        print(f"{GREEN}âœ… {def_type.capitalize()}s written to {output_file}.{RESET}")
    except Exception as e:
        _log_warning(f"Could not write {def_type}s to {output_file}: {e}")
        return

    print(f"---------- Zsh/Bash {def_type.capitalize()} Definitions Summary ----------")
    if not newly_created_or_changed and not verbose:
        print(f"No new or changed Zsh/Bash {def_type}s.")
    elif not newly_created_or_changed and verbose:
        if definitions_to_process:
            print(f"All defined Zsh/Bash {def_type}s were existing and unchanged.")
        else:
            print(f"No Zsh/Bash {def_type}s were defined to process from {Path(source_file_path).name}.")
    
    if newly_created_or_changed:
        if not verbose: print(f"New or Changed Zsh/Bash {def_type.capitalize()}s:")
        for name, (status, desc) in sorted(newly_created_or_changed.items()):
            symbol = "âœ¨" if status == "created" else "ðŸ”„"
            print(f"    {symbol} {name}: {desc}")

    source_command = f"source \"{output_file.resolve()}\""
    print(f"{GREEN}âœ… To apply in your current session, run: {RESET}{YELLOW}{source_command}{RESET}")
    print("---------------------------------------------------------")
