#!/usr/bin/env python3
import re
from pathlib import Path
from typing import List, Dict

# Import the utility function from alias_utils to find the executable symlink path
from scripts_setup.alias_utils import get_executable_path

YELLOW = "\033[93m"
GREEN = "\033[92m"
RESET = "\033[0m"

def _log_warning(message: str):
    print(f"{YELLOW}âš ï¸ {message}{RESET}")

def parse_functions_file(functions_file: Path) -> List[Dict[str, str]]:
    """
    Parses the function_names.txt file using a regular expression for robustness.
    Format: script_filename.py : function_name : "description" : [optional_arguments]
    """
    parsed_functions = []
    if not functions_file.exists():
        _log_warning(f"Function definition file not found: {functions_file}. Skipping.")
        return parsed_functions

    line_pattern = re.compile(r'^\s*([^:]+?)\s*:\s*([^:]+?)\s*:\s*"([^"]+)"\s*:\s*(.*)$')

    with open(functions_file, "r", encoding="utf-8") as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            match = line_pattern.match(line)
            if not match:
                _log_warning(f"Invalid format or missing quotes in {functions_file} (line {line_num}). Skipping. Line: '{line}'")
                continue

            script_file, func_name, description, args_str = match.groups()
            parsed_functions.append({
                "script": script_file.strip(),
                "name": func_name.strip(),
                "description": description.strip(),
                "args": args_str.strip()
            })
    return parsed_functions

def get_existing_functions(function_config: Path) -> Dict[str, str]:
    """
    Reads an existing generated function file and extracts function names and
    their full text blocks for comparison.
    """
    functions = {}
    if not function_config.exists():
        return functions
    try:
        full_text = function_config.read_text(encoding='utf-8')
        # Split by the blank line between each full function definition
        # filter(None, ...) removes any empty strings that result from splitting
        blocks = filter(None, full_text.split('\n\n'))
        for block in blocks:
            # The name can be extracted from the first line for the key
            match = re.search(r'register_function\s+"([^"]+)"', block)
            if match:
                name = match.group(1)
                functions[name] = block.strip()
    except Exception as e:
        _log_warning(f"Error reading existing function file {function_config}: {e}")
    return functions

def write_functions(
    parsed_functions: List[Dict[str, str]],
    bin_dir: Path,
    output_file: Path,
    source_file_path: str,
    verbose: bool = False
) -> None:
    """
    Writes the parsed functions to a Zsh script file using the custom syntax
    and provides a detailed summary of changes.
    """
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    existing_functions_map = get_existing_functions(output_file)
    newly_created_or_changed = {}
    functions_to_process = {}
    all_lines = [
        f"# Generated by function_utils.py from {Path(source_file_path).name}",
        "# Do not edit this file directly. Modify the source and rerun the setup.",
    ]

    sorted_functions = sorted(parsed_functions, key=lambda x: x['name'])
    
    for func_def in sorted_functions:
        func_name = func_def['name']
        symlink_path = get_executable_path(bin_dir, func_def['script'])
        command = str(symlink_path)
        
        if func_def['args']:
            command += f" {func_def['args']}"
        
        full_command = f'{command} "$@"'

        # Construct the full text block for this function in the desired custom format
        func_block_lines = [
            f'register_function "{func_name}" "{func_def["description"]}"',
            f"{func_name}() {{",
            f'    {full_command.strip()}',
            f"}}"
        ]
        func_block_text = "\n".join(func_block_lines)
        
        if func_name in functions_to_process:
            _log_warning(f"Duplicate function name '{func_name}' defined in {Path(source_file_path).name}. Using last definition.")
        functions_to_process[func_name] = func_block_text

    # Compare and report changes, similar to the alias logic
    sorted_func_names = sorted(functions_to_process.keys())

    for name in sorted_func_names:
        block_text = functions_to_process[name]
        if name in existing_functions_map and existing_functions_map[name] == block_text:
            if verbose: print(f"ðŸ”¹ Function unchanged: {name}")
        else:
            description = next((f['description'] for f in parsed_functions if f['name'] == name), "")
            if name in existing_functions_map:
                newly_created_or_changed[name] = ('updated', description)
                if verbose: print(f"ðŸ”„ Function updated: {name}")
            else:
                newly_created_or_changed[name] = ('created', description)
                if verbose: print(f"âœ¨ Function created: {name}")

        all_lines.append("") # Add a blank line separator
        all_lines.append(block_text)

    try:
        with open(output_file, "w", encoding="utf-8") as f:
            f.write("\n".join(all_lines) + "\n")
        print(f"{GREEN}âœ… Functions written to {output_file}.{RESET}")
    except Exception as e:
        _log_warning(f"Could not write functions to {output_file}: {e}")
        return

    # --- Mirrored Summary Output ---
    print("---------- Zsh/Bash Function Definitions Summary ----------")
    if not newly_created_or_changed and not verbose:
        print("No new or changed Zsh/Bash functions.")
    elif not newly_created_or_changed and verbose:
        if functions_to_process:
            print("All defined Zsh/Bash functions were existing and unchanged.")
        else:
            print(f"No Zsh/Bash functions were defined to process from {Path(source_file_path).name}.")
    
    if newly_created_or_changed:
        if not verbose: print("New or Changed Zsh/Bash Functions:")
        for name, (status, desc) in sorted(newly_created_or_changed.items()):
            symbol = "âœ¨" if status == "created" else "ðŸ”„"
            print(f"    {symbol} {name}: {desc}")

    source_command = f"source \"{output_file.resolve()}\""
    print(f"{GREEN}âœ… To apply in your current session, run: {RESET}{YELLOW}{source_command}{RESET}")
    print("---------------------------------------------------------")
