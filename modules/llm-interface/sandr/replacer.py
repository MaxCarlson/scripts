#!/usr/bin/env python3
# File: sandr/replacer.py

"""
Applies multi-file, multi-edit code modifications from the clipboard
using a robust search-and-replace format generated by an LLM.
"""

import argparse
import difflib
import re
import sys
from pathlib import Path
from typing import List, Dict, Any, Literal

try:
    from cross_platform.clipboard_utils import get_clipboard
    from rich.console import Console
    from rich.panel import Panel
    from rich.prompt import Confirm
    from rich.syntax import Syntax
except ImportError as e:
    print(f"Error: Missing required packages. Please install 'rich' and ensure 'cross_platform' is in your PYTHONPATH.", file=sys.stderr)
    print(f"--> ImportError: {e}", file=sys.stderr)
    sys.exit(1)

# --- Globals ---
console = Console()

# --- Format Parsing ---

def parse_clipboard_content(text: str) -> List[Dict[str, Any]]:
    """
    Parses the clipboard content into a structured list of operations.
    """
    operations = []
    file_pattern = re.compile(
        r"\[(START_FILE_CREATE|START_FILE_EDIT): (.+?)\]\n(.*?)\n\[END_FILE\]", re.DOTALL
    )
    replace_pattern = re.compile(
        r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE", re.DOTALL
    )
    insert_pattern = re.compile(
        r"<<<<<<< INSERT\n(.*?)\n=======\n(BEFORE|AFTER)\n<<<<<<< ANCHOR\n(.*?)\n>>>>>>> ANCHOR", re.DOTALL
    )

    for match in file_pattern.finditer(text):
        op_type, file_path_str, content_block = match.groups()
        file_path = Path(file_path_str.strip())

        if op_type == "START_FILE_CREATE":
            operations.append(
                {"type": "create", "path": file_path, "content": content_block}
            )
        elif op_type == "START_FILE_EDIT":
            # Corrected: Combine patterns and find all edits in order.
            combined_pattern = re.compile(
                r"(<<<<<<< SEARCH\n.*?\n=======\n.*?\n>>>>>>> REPLACE|<<<<<<< INSERT\n.*?\n=======\n(?:BEFORE|AFTER)\n<<<<<<< ANCHOR\n.*?\n>>>>>>> ANCHOR)",
                re.DOTALL
            )
            for edit_match in combined_pattern.finditer(content_block):
                full_edit_block = edit_match.group(1)
                
                # Check if it's a REPLACE block
                rep_match = replace_pattern.fullmatch(full_edit_block)
                if rep_match:
                    search_block, replace_block = rep_match.groups()
                    operations.append(
                        {"type": "replace", "path": file_path, "search": search_block, "replace": replace_block}
                    )
                    continue

                # Check if it's an INSERT block
                ins_match = insert_pattern.fullmatch(full_edit_block)
                if ins_match:
                    insert_content, position, anchor_block = ins_match.groups()
                    operations.append({
                        "type": "insert",
                        "path": file_path,
                        "content": insert_content,
                        "position": position.lower(),
                        "anchor": anchor_block,
                    })

    return operations

# --- Change Application ---

def preview_and_apply_changes(operations: List[Dict[str, Any]], dry_run: bool, auto_confirm: bool):
    """
    Previews, confirms, and applies the list of parsed operations.
    """
    if not operations:
        console.print("[bold yellow]No valid edit operations found in clipboard content.[/bold yellow]")
        return

    console.rule("[bold cyan]Planned Code Modifications[/bold cyan]", style="cyan")
    
    # Corrected: Handle state changes between operations on the same file.
    planned_writes: Dict[Path, str] = {}
    validation_passed = True

    for i, op in enumerate(operations):
        path = op['path']
        op_type = op['type'].upper()
        color = { "CREATE": "green", "REPLACE": "yellow", "INSERT": "blue" }.get(op_type, "white")
        
        console.print(Panel(
            f"[bold {color}]{op_type}[/bold {color}] -> [cyan]{path}[/cyan]",
            title=f"Operation {i + 1}/{len(operations)}", expand=False, border_style=color
        ))
        
        try:
            original_content = planned_writes.get(path)
            if original_content is None: # First time seeing this file
                if path.is_file():
                    original_content = path.read_text('utf-8')
                else: # File doesn't exist yet
                    original_content = ""
            
            new_content = original_content

            if op['type'] == 'create':
                if path.exists():
                    raise FileExistsError(f"File '{path}' already exists.")
                new_content = op['content']
            
            elif op['type'] == 'replace':
                anchor = op['search']
                if not anchor: raise ValueError("SEARCH block cannot be empty.")
                if original_content.count(anchor) != 1: raise ValueError(f"SEARCH block not unique (found {original_content.count(anchor)} times).")
                new_content = original_content.replace(anchor, op['replace'])

            elif op['type'] == 'insert':
                anchor = op['anchor']
                if not anchor: raise ValueError("ANCHOR block cannot be empty.")
                if original_content.count(anchor) != 1: raise ValueError(f"ANCHOR block not unique (found {original_content.count(anchor)} times).")
                if op['position'] == 'before':
                    new_content = original_content.replace(anchor, op['content'] + '\n' + anchor)
                else: # after
                    new_content = original_content.replace(anchor, anchor + '\n' + op['content'])
            
            planned_writes[path] = new_content
            diff = difflib.unified_diff(
                original_content.splitlines(keepends=True), new_content.splitlines(keepends=True),
                fromfile=f"a/{path}", tofile=f"b/{path}"
            )
            console.print(Syntax(''.join(diff), "diff", theme="monokai"))

        except Exception as e:
            console.print(f"[bold red]Error previewing operation for '{path}': {e}[/bold red]")
            validation_passed = False
            break

    console.rule(style="cyan")
    if not validation_passed:
        console.print("[bold red]Aborting due to validation errors. No changes will be applied.[/bold red]")
        return

    if dry_run:
        console.print("[bold yellow]DRY RUN MODE: No changes will be applied.[/bold yellow]")
        return

    if not auto_confirm:
        if not Confirm.ask("[bold magenta]Apply these changes?[/bold magenta]", default=False):
            console.print("[bold red]Aborted by user.[/bold red]")
            return
    
    console.rule("[bold green]Applying Changes...[/bold green]", style="green")
    for path, content in planned_writes.items():
        try:
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(content, encoding='utf-8')
            console.print(f"[green]SUCCESS:[/green] Wrote changes to '{path}'")
        except Exception as e:
            console.print(f"[bold red]ERROR writing to '{path}': {e}[/bold red]")
            
    console.rule("[bold green]All operations complete.[/bold green]", style="green")

def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Apply LLM-generated contextual search-and-replace edits from the clipboard.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="Use -y to auto-confirm changes, -d for a dry run."
    )
    parser.add_argument("-d", "--dry-run", action="store_true", help="Parse and preview changes without applying.")
    parser.add_argument("-y", "--yes", action="store_true", help="Apply all changes without confirmation.")
    args = parser.parse_args()

    try:
        clipboard_text = get_clipboard()
        if not clipboard_text or not clipboard_text.strip():
            console.print("[bold red]Clipboard is empty. Aborting.[/bold red]")
            sys.exit(1)
        
        operations = parse_clipboard_content(clipboard_text)
        preview_and_apply_changes(operations, args.dry_run, args.yes)

    except Exception as e:
        console.print(f"[bold red]An unexpected error occurred: {e}[/bold red]")
        sys.exit(1)

if __name__ == "__main__":
    main()
