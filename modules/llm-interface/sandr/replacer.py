#!/usr/bin/env python3
# File: sandr/replacer.py

"""
Applies multi-file, multi-edit code modifications from the clipboard
using a robust search-and-replace format generated by an LLM.

This script implements the "Contextual Search-and-Replace" methodology,
avoiding the fragility of line-number-based diffs.
"""

import argparse
import difflib
import re
import sys
from pathlib import Path
from typing import List, Dict, Any, Literal

try:
    from cross_platform.clipboard_utils import get_clipboard
    from rich.console import Console
    from rich.panel import Panel
    from rich.prompt import Confirm
    from rich.syntax import Syntax
except ImportError as e:
    print(f"Error: Missing required packages. Please install 'rich' and ensure 'cross_platform' is in your PYTHONPATH.", file=sys.stderr)
    print(f"--> ImportError: {e}", file=sys.stderr)
    sys.exit(1)

# --- Globals ---
console = Console()

# --- Format Parsing ---

def parse_clipboard_content(text: str) -> List[Dict[str, Any]]:
    """
    Parses the clipboard content into a structured list of operations.
    """
    operations = []
    file_pattern = re.compile(
        r"\[(START_FILE_CREATE|START_FILE_EDIT): (.+?)\]\n(.*?)\n\[END_FILE\]", re.DOTALL
    )
    # CORRECTED: Made the final (.*?) group non-greedy and removed the leading newline
    # requirement before the final delimiter to correctly handle empty replacement blocks.
    replace_pattern = re.compile(
        r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE", re.DOTALL
    )
    insert_pattern = re.compile(
        r"<<<<<<< INSERT\n(.*?)\n=======\n(BEFORE|AFTER)\n<<<<<<< ANCHOR\n(.*?)\n>>>>>>> ANCHOR", re.DOTALL
    )

    for match in file_pattern.finditer(text):
        op_type, file_path_str, content = match.groups()
        file_path = Path(file_path_str.strip())

        if op_type == "START_FILE_CREATE":
            operations.append(
                {"type": "create", "path": file_path, "content": content}
            )
        elif op_type == "START_FILE_EDIT":
            edits_in_block = []
            # Use a pointer to process the content block sequentially
            last_pos = 0
            full_content_block = content
            
            # Create a combined pattern to find all edit blocks in order
            edit_pattern = re.compile(
                r"(<<<<<<< SEARCH\n.*?\n=======\n.*?\n>>>>>>> REPLACE|<<<<<<< INSERT\n.*?\n=======\n(?:BEFORE|AFTER)\n<<<<<<< ANCHOR\n.*?\n>>>>>>> ANCHOR)",
                re.DOTALL
            )

            for edit_match in edit_pattern.finditer(full_content_block):
                edit_block_text = edit_match.group(1)

                # Try to match as a REPLACE operation
                rep_match = replace_pattern.match(edit_block_text)
                if rep_match:
                    search_block, replace_block = rep_match.groups()
                    edits_in_block.append(
                        {"type": "replace", "path": file_path, "search": search_block, "replace": replace_block}
                    )
                    continue

                # Try to match as an INSERT operation
                ins_match = insert_pattern.match(edit_block_text)
                if ins_match:
                    insert_content, position, anchor_block = ins_match.groups()
                    edits_in_block.append({
                        "type": "insert",
                        "path": file_path,
                        "content": insert_content,
                        "position": position.lower(),
                        "anchor": anchor_block,
                    })
            
            operations.extend(edits_in_block)

    return operations

# --- Change Application ---

def preview_and_apply_changes(operations: List[Dict[str, Any]], dry_run: bool, auto_confirm: bool):
    """
    Previews, confirms, and applies the list of parsed operations.
    """
    if not operations:
        console.print("[bold yellow]No valid edit operations found in clipboard content.[/bold yellow]")
        return

    console.rule("[bold cyan]Planned Code Modifications[/bold cyan]", style="cyan")
    
    for i, op in enumerate(operations):
        op_type = op['type'].upper()
        color = {
            "CREATE": "green",
            "REPLACE": "yellow",
            "INSERT": "blue"
        }.get(op_type, "white")
        
        console.print(Panel(
            f"[bold {color}]{op_type}[/bold {color}] -> [cyan]{op['path']}[/cyan]",
            title=f"Operation {i + 1}/{len(operations)}",
            expand=False,
            border_style=color
        ))
        
        if op['type'] == 'create':
            console.print(Syntax(op['content'], "python", theme="monokai", line_numbers=True))
        
        elif op['type'] == 'replace':
            try:
                original_content = op['path'].read_text(encoding='utf-8')
                new_content = original_content.replace(op['search'], op['replace'])
                diff = difflib.unified_diff(
                    original_content.splitlines(keepends=True),
                    new_content.splitlines(keepends=True),
                    fromfile=f"a/{op['path']}",
                    tofile=f"b/{op['path']}"
                )
                console.print(Syntax(''.join(diff), "diff", theme="monokai"))
            except FileNotFoundError:
                console.print(f"[red]Original file not found for diffing.[/red]")
            except Exception as e:
                console.print(f"[red]Error generating diff: {e}[/red]")

        elif op['type'] == 'insert':
            try:
                original_content = op['path'].read_text(encoding='utf-8')
                if op['position'] == 'before':
                    new_content = original_content.replace(op['anchor'], op['content'] + '\n' + op['anchor'])
                else: # after
                    new_content = original_content.replace(op['anchor'], op['anchor'] + '\n' + op['content'])
                
                diff = difflib.unified_diff(
                    original_content.splitlines(keepends=True),
                    new_content.splitlines(keepends=True),
                    fromfile=f"a/{op['path']}",
                    tofile=f"b/{op['path']}"
                )
                console.print(Syntax(''.join(diff), "diff", theme="monokai"))
            except FileNotFoundError:
                console.print(f"[red]Original file not found for diffing.[/red]")
            except Exception as e:
                console.print(f"[red]Error generating diff: {e}[/red]")
    
    console.rule(style="cyan")

    if dry_run:
        console.print("[bold yellow]DRY RUN MODE: No changes will be applied.[/bold yellow]")
        return

    if not auto_confirm:
        if not Confirm.ask("[bold magenta]Apply these changes?[/bold magenta]", default=False):
            console.print("[bold red]Aborted by user.[/bold red]")
            return
    
    console.rule("[bold green]Applying Changes...[/bold green]", style="green")
    
    for op in operations:
        try:
            path: Path = op['path']
            op_type = op['type']

            if op_type == 'create':
                if path.exists():
                    console.print(f"[yellow]SKIPPED CREATE:[/yellow] File '{path}' already exists.")
                    continue
                path.parent.mkdir(parents=True, exist_ok=True)
                path.write_text(op['content'], encoding='utf-8')
                console.print(f"[green]CREATED:[/green] New file at '{path}'")

            elif op_type in ['replace', 'insert']:
                if not path.exists():
                    console.print(f"[red]ERROR {op_type.upper()}:[/red] File '{path}' not found.")
                    continue
                
                original_content = path.read_text(encoding='utf-8')
                
                if op_type == 'replace':
                    anchor = op['search']
                    match_count = original_content.count(anchor)
                    if match_count == 0:
                        console.print(f"[red]ERROR REPLACE:[/red] SEARCH block not found in '{path}'.")
                        continue
                    if match_count > 1:
                        console.print(f"[red]ERROR REPLACE:[/red] SEARCH block is not unique ({match_count} occurrences) in '{path}'.")
                        continue
                    new_content = original_content.replace(anchor, op['replace'])

                else: # insert
                    anchor = op['anchor']
                    match_count = original_content.count(anchor)
                    if match_count == 0:
                        console.print(f"[red]ERROR INSERT:[/red] ANCHOR block not found in '{path}'.")
                        continue
                    if match_count > 1:
                        console.print(f"[red]ERROR INSERT:[/red] ANCHOR block is not unique ({match_count} occurrences) in '{path}'.")
                        continue
                    
                    if op['position'] == 'before':
                        new_content = original_content.replace(anchor, op['content'] + '\n' + anchor)
                    else: # after
                        new_content = original_content.replace(anchor, anchor + '\n' + op['content'])

                path.write_text(new_content, encoding='utf-8')
                console.print(f"[green]MODIFIED:[/green] Applied {op_type} to '{path}'")

        except Exception as e:
            console.print(f"[bold red]FATAL ERROR applying operation to '{op.get('path')}': {e}[/bold red]")
            
    console.rule("[bold green]All operations complete.[/bold green]", style="green")


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Apply LLM-generated contextual search-and-replace edits from the clipboard.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "-d", "--dry-run",
        action="store_true",
        help="Parse the clipboard and preview all changes without applying them."
    )
    parser.add_argument(
        "-y", "--yes",
        action="store_true",
        help="Apply all changes without asking for confirmation."
    )
    args = parser.parse_args()

    try:
        clipboard_text = get_clipboard()
        if not clipboard_text or not clipboard_text.strip():
            console.print("[bold red]Clipboard is empty. Aborting.[/bold red]")
            sys.exit(1)
        
        operations = parse_clipboard_content(clipboard_text)
        preview_and_apply_changes(operations, args.dry_run, args.yes)

    except Exception as e:
        console.print(f"[bold red]An unexpected error occurred: {e}[/bold red]")
        sys.exit(1)

if __name__ == "__main__":
    main()
