# File Replacer Interactive Mode - Design Document

## Overview

This document describes the comprehensive enhancement of the `file_utils.replacer` module to support an advanced interactive mode. The goal is to provide a powerful, Git-like interface for previewing, managing, and applying bulk text replacements across multiple files with full operation history and undo/redo capabilities.

## Table of Contents

1. [Current State](#current-state)
2. [Enhanced Dry-Run Mode](#enhanced-dry-run-mode)
3. [Interactive Mode](#interactive-mode)
4. [Architecture](#architecture)
5. [Implementation Plan](#implementation-plan)
6. [Future Enhancements](#future-enhancements)

---

## Current State

### Existing Features
- âœ… Basic find and replace with ripgrep
- âœ… Delete entire lines containing matches
- âœ… First-only, specific-line, max-per-file controls
- âœ… Dry-run mode (basic)
- âœ… Statistics and analysis mode
- âœ… Verbose output with diffs

### Limitations
- Dry-run mode outputs too much information without clear structure
- No way to preview changes before applying
- No undo/redo functionality
- No way to chain operations
- No interactive exploration of changes
- No visual file tree navigation

---

## Enhanced Dry-Run Mode

### Purpose
Provide a clear, concise preview of what would happen without overwhelming the user.

### Behavior

#### Default Output (Non-Verbose)
```
Searching for pattern: ^File:

Found 15 matches in 8 files

DRY RUN - No changes will be made
============================================================
Would delete 15 lines across 8 files:

  src/utils/helper.py     - 2 lines
  src/main.py             - 1 line
  tests/test_utils.py     - 3 lines
  lib/parser.py           - 1 line
  ...

Files affected: 8
Total operations: 15
============================================================

Run without --dry-run to apply changes
Run with --verbose to see detailed diffs
Run with --interactive to review changes interactively
```

#### Verbose Output
When `-v/--verbose` is added, show detailed diffs for each file:

```
Searching for pattern: ^File:

Found 15 matches in 8 files

DRY RUN - Detailed Preview
============================================================

[1/8] src/utils/helper.py (2 changes)
----------------------------------------
--- a/src/utils/helper.py
+++ b/src/utils/helper.py
@@ -1,4 +1,2 @@
-File: helper.py
-File: autogenerated
 #!/usr/bin/env python
 """Helper utilities."""

[2/8] src/main.py (1 change)
----------------------------------------
--- a/src/main.py
+++ b/src/main.py
@@ -1,3 +1,2 @@
-File: main.py
 #!/usr/bin/env python
 """Main entry point."""

... [remaining files] ...

============================================================
Summary:
  Files affected: 8
  Total operations: 15
  Lines deleted: 15
  Lines added: 0
============================================================

Run without --dry-run to apply changes
Run with --interactive to review and edit operations
```

### Key Improvements
1. **Concise by default**: Show file list and counts
2. **Detailed on demand**: Use `-v` for full diffs
3. **Clear guidance**: Tell user what to do next
4. **Operation summary**: Always show total impact

---

## Interactive Mode

### Overview
Interactive mode provides a TUI (Terminal User Interface) for:
- Previewing changes in a scrollable diff viewer
- Navigating modified files via a tree view
- Chaining multiple operations sequentially
- Rewinding/redoing operations
- Selectively applying/reverting changes
- Stashing states for later

### Activation
```bash
file-util replace -p "pattern" -r "replacement" --interactive
# OR shorthand
file-util replace -p "pattern" -r "replacement" -I
```

### Interface Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ File Replacer - Interactive Mode                    Operation #1 of 1       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Modified Files        â”‚ Diff Viewer                                         â”‚
â”‚                       â”‚                                                     â”‚
â”‚ â–¼ src/               â”‚ --- a/src/utils/helper.py                           â”‚
â”‚   â–¶ components/      â”‚ +++ b/src/utils/helper.py                           â”‚
â”‚   â–¼ utils/           â”‚ @@ -1,4 +1,2 @@                                     â”‚
â”‚     helper.py +2/-4  â”‚ -File: helper.py                                    â”‚
â”‚     parser.py +0/-1  â”‚ -File: autogenerated                                â”‚
â”‚ â–¼ tests/             â”‚  #!/usr/bin/env python                              â”‚
â”‚     test_utils.py    â”‚  """Helper utilities."""                            â”‚
â”‚                 +1/-3â”‚                                                     â”‚
â”‚                       â”‚ @@ -45,2 +43,1 @@                                  â”‚
â”‚ [8 files, +12/-18]    â”‚ -# TODO: Remove this                               â”‚
â”‚                       â”‚ +# Updated implementation                           â”‚
â”‚ [H]ide tree           â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ Commands: [A]pply [Q]uit [R]evert [N]ew-op [P]rev-op [S]tash [?]Help       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Components

#### 1. File Tree Panel (Left)
- **Hierarchical view** of all modified files
- **Expand/collapse** folders with `â–¶`/`â–¼` indicators
- **Color coding**:
  - ğŸŸ¢ **Green**: More additions than deletions
  - ğŸ”´ **Red**: More deletions than additions
  - ğŸŸ¡ **Yellow**: Equal additions/deletions
  - âšª **White**: Unmodified (parent folders)
- **Diff counts**: Show `+XX/-YY` next to each file
- **Aggregate counts**: Folders show sum of child diffs
- **Selection**: Highlight current file being viewed
- **Toggle visibility**: Press `H` to hide/show for full-screen diff
- **Navigation**:
  - `â†‘`/`â†“` or `j`/`k` to move between files
  - `Enter` to view file's diff
  - `Space` to toggle expand/collapse folder

#### 2. Diff Viewer Panel (Right)
- **Scrollable view** of selected file's diff
- **Unified diff format** with syntax highlighting
- **Line numbers** on both sides (original/modified)
- **Context lines** (default 3, configurable)
- **Color coding**:
  - ğŸŸ¢ Green for additions (`+`)
  - ğŸ”´ Red for deletions (`-`)
  - ğŸ”µ Cyan for context headers (`@@`)
  - âšª White for unchanged lines
- **Navigation**:
  - `â†‘`/`â†“` or `j`/`k` to scroll line by line
  - `Page Up`/`Page Down` for page scrolling
  - `g`/`G` to go to top/bottom
  - `n`/`N` to jump to next/previous hunk

#### 3. Header Bar (Top)
- **Title**: "File Replacer - Interactive Mode"
- **Operation counter**: "Operation #N of M"
- **Current pattern/replacement** info (if space allows)

#### 4. Command Bar (Bottom)
- **Available commands** with keyboard shortcuts
- **Contextual help** based on current state

### Core Operations

#### A. Apply Changes
**Shortcut**: `A` or `Enter`

**Behavior**:
1. Apply all pending changes from current operation
2. Write changes to disk
3. Mark operation as "applied"
4. Remain in interactive mode
5. Show confirmation message
6. New operations start from this state

**Prompts**:
```
Apply all changes? [Y/n]: _
Applying 15 changes across 8 files...
âœ“ Applied successfully
```

#### B. Apply and Exit
**Shortcut**: `Ctrl+A` or `W` (write)

**Behavior**:
1. Apply all pending changes
2. Write changes to disk
3. Show summary
4. Exit interactive mode

**Output**:
```
Applied 15 changes across 8 files
Exiting...
```

#### C. Revert Changes
**Shortcut**: `R`

**Behavior**:
1. Discard current operation
2. Revert to previous operation's state (or original if at Operation #1)
3. Update UI to show previous state
4. Keep operation history for re-applying

**Prompts**:
```
Revert current operation? This will discard pending changes. [y/N]: _
Reverted to Operation #0 (original state)
```

#### D. New Operation
**Shortcut**: `N`

**Behavior**:
1. Prompt for new search pattern and operation type
2. Apply new operation to files as if previous operations were already applied
3. Generate new diffs based on cumulative state
4. Increment operation counter
5. Add to operation history

**Flow**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ New Operation                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Pattern: â–ˆ                                              â”‚
â”‚ Replacement: _________                                  â”‚
â”‚ Delete line instead? [y/N]: _                           â”‚
â”‚ First only? [y/N]: _                                    â”‚
â”‚ Max per file: [blank for no limit] _                    â”‚
â”‚                                                         â”‚
â”‚ [Enter] to run  [Esc] to cancel                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

After entering parameters:
```
Running operation #2...
Found 8 matches in 3 files
Generated diffs based on Operation #1 state
Ready for review
```

#### E. Navigate Operations
**Shortcuts**:
- `P` or `â†`: Previous operation
- `Next` or `â†’`: Next operation (if available)

**Behavior**:
1. Switch to viewing specified operation's diffs
2. Update file tree to show that operation's changes
3. Update header to show current operation number
4. Allow applying, reverting, or editing from any operation

**Notes**:
- Operations are immutable once created
- Can view any past operation
- Can rewind to earlier state and branch from there

#### F. Quit Without Saving
**Shortcut**: `Q` or `Ctrl+C`

**Behavior**:
1. Check if there are unapplied changes
2. Prompt for confirmation if changes pending
3. Exit without writing any changes
4. Restore original file states

**Prompts**:
```
You have unapplied changes. Quit without saving? [y/N]: _
```

#### G. Stash State
**Shortcut**: `S`

**Behavior** (Future):
1. Save current operation state with a name
2. Allow recalling stashed states later
3. Useful for trying multiple approaches

### Operation Chaining

#### Conceptual Model
Operations form a **sequential chain** where each operation builds on the previous one:

```
Operation #0 (Original)
    â†“
Operation #1: Replace "foo" â†’ "bar"
    â†“ (files now have "bar" instead of "foo")
Operation #2: Delete lines with "bar"
    â†“ (files now have "bar" lines removed)
Operation #3: Replace "baz" â†’ "qux"
    â†“ (search operates on state after Op #1 and #2)
```

#### Key Principles
1. **Cumulative state**: Each operation sees the files as if all previous operations were applied
2. **Independent searches**: ripgrep searches are always against the cumulative state
3. **Rewindable**: Can go back to any previous operation
4. **Branching**: Can rewind and create new operation chains from any point

#### Implementation Details
- **In-memory state**: Keep modified file contents in memory for each operation
- **Virtual filesystem**: Apply operations to in-memory copies, not actual files
- **Lazy writing**: Only write to disk when user explicitly applies
- **State snapshots**: Store file state after each operation for instant rewinding

### File Selection and Scope

#### Scope Definition
- **Initial scope**: All files matching the initial search pattern within starting directory
- **Expanding scope**: New operations can match files outside initial scope if they're within the root directory
- **Root directory**:
  - Specified via `--path` argument
  - Defaults to current directory (`.`)
  - All subdirectories are included

#### Examples
```bash
# Start in current directory
file-util replace -p "pattern" -r "replacement" -I

# Start in specific directory
file-util replace -p "pattern" -r "replacement" --path src/ -I
```

If Operation #1 matches files in `src/utils/`, and Operation #2 is entered with a new pattern, it can match files in `src/components/` even if they weren't in Operation #1's results.

---

## Architecture

### Component Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CLI Entry Point                        â”‚
â”‚              (cli.py: replace command)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                               â”‚
     â–¼                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Non-Inter  â”‚              â”‚  Interactive â”‚
â”‚    Mode     â”‚              â”‚     Mode     â”‚
â”‚ (current)   â”‚              â”‚    (new)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚              â”‚              â”‚
                     â–¼              â–¼              â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  Operation â”‚ â”‚   State   â”‚ â”‚   TUI    â”‚
              â”‚  Manager   â”‚ â”‚  Manager  â”‚ â”‚  Engine  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Core Classes

#### 1. `OperationManager`
**Purpose**: Manage operation history and execution

**Responsibilities**:
- Store operation parameters (pattern, replacement, flags)
- Execute operations against a given file state
- Track operation sequence
- Support undo/redo

**Key Methods**:
```python
class OperationManager:
    def __init__(self):
        self.operations: List[Operation] = []
        self.current_index: int = 0

    def add_operation(self, op: Operation) -> int:
        """Add new operation, returns operation ID"""

    def execute_operation(self, op: Operation, state: FileState) -> FileState:
        """Execute operation on given state, return new state"""

    def get_operation(self, index: int) -> Operation:
        """Get operation by index"""

    def rewind_to(self, index: int) -> FileState:
        """Rewind to specific operation"""
```

#### 2. `FileState`
**Purpose**: Represent the state of all files at a point in time

**Responsibilities**:
- Store in-memory file contents
- Track which files are modified
- Generate diffs between states
- Support cloning for branching

**Key Methods**:
```python
class FileState:
    def __init__(self):
        self.files: Dict[Path, FileContent] = {}
        self.modified: Set[Path] = set()

    def get_file(self, path: Path) -> str:
        """Get file content (from memory or disk)"""

    def set_file(self, path: Path, content: str):
        """Set file content in memory"""

    def get_diff(self, other: FileState, path: Path) -> str:
        """Generate diff between this state and another"""

    def clone(self) -> FileState:
        """Create deep copy of state"""

    def write_to_disk(self):
        """Write all modified files to disk"""
```

#### 3. `FileContent`
**Purpose**: Store content and metadata for a single file

**Structure**:
```python
@dataclass
class FileContent:
    path: Path
    original_lines: List[str]
    current_lines: List[str]
    modifications: List[Modification]

    @property
    def is_modified(self) -> bool:
        return self.original_lines != self.current_lines

    @property
    def diff_stats(self) -> Tuple[int, int]:
        """Returns (additions, deletions)"""
```

#### 4. `InteractiveTUI`
**Purpose**: Render and manage the interactive interface

**Responsibilities**:
- Render file tree panel
- Render diff viewer panel
- Handle keyboard input
- Update UI based on state changes
- Coordinate with OperationManager and StateManager

**Key Methods**:
```python
class InteractiveTUI:
    def __init__(self, state_manager: StateManager, op_manager: OperationManager):
        self.state_mgr = state_manager
        self.op_mgr = op_manager
        self.tree_panel = FileTreePanel()
        self.diff_panel = DiffViewerPanel()

    def run(self):
        """Main event loop"""

    def render(self):
        """Render entire UI"""

    def handle_key(self, key: int):
        """Process keyboard input"""

    def show_operation_dialog(self) -> Operation:
        """Show dialog for new operation parameters"""
```

#### 5. `FileTreePanel`
**Purpose**: Render hierarchical file tree with diff stats

**Key Methods**:
```python
class FileTreePanel:
    def render(self, state: FileState, selected: Path):
        """Render tree for current state"""

    def get_file_color(self, stats: Tuple[int, int]) -> int:
        """Determine color based on +/- stats"""

    def navigate(self, direction: str) -> Path:
        """Handle navigation, return new selected path"""
```

#### 6. `DiffViewerPanel`
**Purpose**: Render scrollable unified diff

**Key Methods**:
```python
class DiffViewerPanel:
    def render(self, diff: str, scroll_offset: int):
        """Render diff with line numbers and colors"""

    def scroll(self, amount: int):
        """Scroll by N lines"""

    def jump_to_hunk(self, direction: str):
        """Jump to next/prev diff hunk"""
```

#### 7. `Operation`
**Purpose**: Encapsulate a single operation's parameters

**Structure**:
```python
@dataclass
class Operation:
    id: int
    pattern: str
    replacement: Optional[str]
    delete_line: bool
    first_only: bool
    specific_line: Optional[int]
    max_per_file: Optional[int]
    ignore_case: bool
    blank_on_delete: bool
    timestamp: datetime

    def execute(self, file_content: str) -> str:
        """Execute operation on file content"""
```

---

## Implementation Plan

### Phase 1: Enhanced Dry-Run Mode âœ…
**Goal**: Improve non-interactive dry-run output

**Tasks**:
1. âœ… Refactor dry-run output to be concise by default
2. âœ… Add file-by-file summary without full diffs
3. âœ… Show detailed diffs only with `-v`
4. âœ… Add clear guidance for next steps
5. âœ… Update tests

**Files**:
- `replacer.py`: Update `run_replacer()` function

**Estimated Time**: 2-4 hours

---

### Phase 2: Operation and State Management ğŸ”„
**Goal**: Build core state management infrastructure

**Tasks**:
1. Create `Operation` dataclass
2. Create `FileContent` dataclass
3. Create `FileState` class with in-memory file storage
4. Create `OperationManager` class
5. Implement operation execution against FileState
6. Implement state cloning and diffing
7. Add comprehensive tests

**Files**:
- `replacer_state.py` (new): FileState, FileContent
- `replacer_operations.py` (new): Operation, OperationManager
- `tests/replacer_state_test.py` (new)
- `tests/replacer_operations_test.py` (new)

**Estimated Time**: 8-12 hours

---

### Phase 3: Basic Interactive Mode ğŸ”„
**Goal**: Launch interactive mode with minimal functionality

**Tasks**:
1. Create `InteractiveTUI` base class using curses
2. Implement basic two-panel layout (tree + diff)
3. Add keyboard navigation
4. Implement apply/quit commands
5. Hook into existing `run_replacer()` when `--interactive` flag present
6. Add initial tests (where possible with curses)

**Files**:
- `replacer_interactive.py` (new): InteractiveTUI
- `cli.py`: Add `--interactive` / `-I` flag
- `replacer.py`: Call interactive mode when flag present

**Estimated Time**: 12-16 hours

---

### Phase 4: File Tree Panel ğŸ”„
**Goal**: Build rich file tree with expand/collapse and stats

**Tasks**:
1. Create `FileTreePanel` class
2. Implement hierarchical rendering
3. Add expand/collapse functionality
4. Calculate and display diff stats (+/-) per file
5. Implement color coding based on change type
6. Add navigation (up/down, enter to select)
7. Implement toggle hide/show

**Files**:
- `replacer_tree_panel.py` (new): FileTreePanel
- `replacer_interactive.py`: Integrate FileTreePanel

**Estimated Time**: 8-12 hours

---

### Phase 5: Diff Viewer Panel ğŸ”„
**Goal**: Build scrollable diff viewer with syntax highlighting

**Tasks**:
1. Create `DiffViewerPanel` class
2. Implement unified diff rendering
3. Add line-by-line scrolling
4. Add page scrolling
5. Implement hunk jumping (next/prev)
6. Add color coding for +/- lines
7. Add line numbers

**Files**:
- `replacer_diff_panel.py` (new): DiffViewerPanel
- `replacer_interactive.py`: Integrate DiffViewerPanel

**Estimated Time**: 8-12 hours

---

### Phase 6: Operation Chaining ğŸ”„
**Goal**: Allow creating new operations from current state

**Tasks**:
1. Implement "New Operation" dialog in TUI
2. Hook up dialog to OperationManager
3. Execute new operation on current FileState
4. Generate diffs for new operation
5. Update UI to show new operation
6. Test operation chaining logic
7. Add operation counter display

**Files**:
- `replacer_interactive.py`: Add operation dialog
- `replacer_operations.py`: Ensure proper chaining

**Estimated Time**: 6-10 hours

---

### Phase 7: Operation History and Rewinding ğŸ”„
**Goal**: Allow navigating through operation history

**Tasks**:
1. Implement `rewind_to()` in OperationManager
2. Add "Previous Operation" / "Next Operation" commands
3. Add "Revert" command to discard current operation
4. Update UI to show operation number
5. Store operation history
6. Test rewinding logic thoroughly

**Files**:
- `replacer_operations.py`: Add rewind logic
- `replacer_interactive.py`: Add navigation commands

**Estimated Time**: 6-8 hours

---

### Phase 8: Polish and Testing ğŸ”„
**Goal**: Bug fixes, performance, documentation

**Tasks**:
1. Add comprehensive integration tests
2. Performance testing with large file sets
3. Memory profiling and optimization
4. Error handling and edge cases
5. Update README with interactive mode docs
6. Create tutorial/examples
7. Add help screen in TUI (`?` key)

**Files**:
- All files: Bug fixes and polish
- `README.md`: Update documentation
- `REPLACER_TUTORIAL.md` (new): Interactive mode guide

**Estimated Time**: 8-12 hours

---

### Phase 9: Future Enhancements ğŸ”®
**Goal**: Advanced features for power users

**Tasks** (Future):
1. Stashing states
2. Saving/loading operation sessions
3. Selective file application (apply only some files)
4. Regex pattern testing before operation
5. Integration with version control (git)
6. Performance improvements for very large codebases
7. Configuration file for defaults
8. Plugin system for custom operations

---

## Future Enhancements

### 1. Stashing
```bash
# In interactive mode:
Press 'S' â†’ Stash current state
Enter stash name: "before-refactor"
Stashed successfully
```

List stashes:
```
Stashes:
  1. before-refactor (3 operations, 15 files)
  2. experiment-1 (1 operation, 5 files)
```

Apply stash:
```
Press 'L' â†’ Load stash
Select stash: [list navigation]
```

### 2. Selective Application
Apply changes to only specific files:
```
In file tree:
  [x] src/utils/helper.py
  [ ] src/main.py
  [x] tests/test_utils.py

Press 'A' â†’ Apply only checked files
```

### 3. Pattern Testing
Before running operation, test regex:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Pattern Tester                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Pattern: ^File:\s*\w+                   â”‚
â”‚ Test String: File: test.py              â”‚
â”‚                                         â”‚
â”‚ Match: âœ“ Yes                            â”‚
â”‚ Groups: []                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. Session Save/Load
Save entire operation history:
```bash
file-util replace --load-session refactor-2024.json
```

### 5. Git Integration
```
Changes ready for git?
  [ ] Create commit automatically
  [ ] Add to staging area
  [x] Just write files
```

---

## Technical Considerations

### Performance
- **Large files**: Stream files in chunks, don't load entire file into memory
- **Many files**: Use pagination in file tree (load/unload as user scrolls)
- **Diff generation**: Cache diffs, regenerate only when needed
- **State storage**: Use copy-on-write semantics where possible

### Memory
- **In-memory limits**: If operation modifies 1000+ files, consider disk-backed state
- **Garbage collection**: Clean up old states when moving forward (unless stashed)

### Error Handling
- **File permissions**: Gracefully handle read/write errors
- **File changes**: Detect if files changed on disk during session
- **Curses errors**: Handle terminal resize, signal interrupts

### Testing
- **Unit tests**: Test all classes independently
- **Integration tests**: Test operation chains and state management
- **TUI tests**: Mock curses where possible, use snapshot testing
- **End-to-end tests**: Automated tests on real file structures

### Cross-Platform
- **Windows**: Ensure curses works (windows-curses package)
- **Color support**: Detect and adapt to terminal capabilities
- **Path handling**: Use pathlib consistently

---

## Success Criteria

### Must Have (MVP)
- âœ… Enhanced dry-run mode with concise output
- âœ… Interactive mode launches successfully
- âœ… File tree shows all modified files
- âœ… Diff viewer displays changes
- âœ… Apply/Quit commands work
- âœ… New operation can be added
- âœ… Operations chain correctly
- âœ… Can rewind to previous operations

### Should Have
- âœ… Color-coded file tree
- âœ… Diff stats (+XX/-YY) displayed
- âœ… Tree expand/collapse
- âœ… Operation counter
- âœ… Smooth keyboard navigation
- âœ… Help screen

### Nice to Have (Future)
- â³ Stashing
- â³ Session save/load
- â³ Selective application
- â³ Git integration
- â³ Pattern testing

---

## Example Usage Scenarios

### Scenario 1: Simple Refactor
```bash
# Start interactive mode
file-util replace -p "oldFunc" -r "newFunc" -I

# User sees:
# - 25 files matched
# - Tree shows all files with +1/-1
# - Diff shows oldFunc â†’ newFunc

# User presses 'A' to apply
# Changes written successfully
```

### Scenario 2: Multi-Step Refactor
```bash
# Start with removing debug lines
file-util replace -p "console\.log" -d -I

# Operation #1: 15 files, 23 matches
# User presses 'N' for new operation

# New operation: Rename variable
Pattern: oldVar
Replacement: newVar

# Operation #2 runs on state after Operation #1
# User sees cumulative changes

# User presses 'A' to apply both operations
```

### Scenario 3: Experimenting
```bash
# Start operation
file-util replace -p "pattern" -r "replacement" -I

# User doesn't like the changes
# Presses 'R' to revert

# Tries new operation with different pattern
# Presses 'N' and enters new parameters
# Reviews new results

# Likes this better, presses 'A' to apply
```

### Scenario 4: Reviewing Large Change
```bash
# Operation affects 100 files
file-util replace -p "old" -r "new" -I

# User navigates through file tree
# Presses 'H' to hide tree for full-screen diff
# Scrolls through each file's changes
# Presses 'H' again to show tree
# Satisfied, presses 'A' to apply
```

---

## Open Questions

1. **Memory limits**: What's the maximum reasonable number of files to keep in memory?
   - **Answer**: Start with 1000 files, measure and optimize

2. **Undo depth**: How many operations should we keep in history?
   - **Answer**: Unlimited by default, add config option later

3. **File watching**: Should we detect if files change on disk during session?
   - **Answer**: Yes, warn user but don't auto-reload

4. **Conflict resolution**: What if user's new operation conflicts with previous ones?
   - **Answer**: Just apply sequentially, show warnings if pattern doesn't match

5. **Async operations**: Should large operations run in background?
   - **Answer**: Phase 2 feature, start with synchronous

---

## Conclusion

This design provides a powerful, intuitive interface for bulk text operations while maintaining full control and visibility. The phased implementation approach allows for incremental development and testing, with each phase delivering tangible value.

The architecture is designed to be:
- **Modular**: Each component has clear responsibilities
- **Testable**: Core logic separated from UI
- **Extensible**: Easy to add new operations and features
- **Performant**: Optimized for typical use cases (10-1000 files)
- **User-friendly**: Clear visual feedback and simple commands

By following this design, we'll create a tool that transforms tedious bulk editing tasks into an interactive, enjoyable experience.
